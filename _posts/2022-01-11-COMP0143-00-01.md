---
layout: single
title: "Cryptography: Hash Functions"
excerpt_separator: <!--more-->
tags: UCL-Course COMP0143 Blockchain
author_profile: true
read_time: true
toc: true
classes: wide
---

UCL Course COMP0143 Cryptocurrencies: Prerequisite Cryptography Part I

<!--more-->

---
### Hash Functions

#### Motivation

Passwords stored in server database should not be stored in plaintext

Possible Solutions:

- Using encryption: have to care about the secret keys

- Using one-way function: have to care about the possible collisions

    e.g., given the one-way function \\(f\\), there could exist a password \\(pw^\prime \neq pw\\) but \\(f(pw^\prime) = f(pw)\\)


#### Definition

***Hash Function*** is a one-way function  

which maps **<span style="color:Red">arbitrary-sized</span>** input \\(m\\) into an output \\(h\\) with **<span style="color:Red">fixed-length</span>** \\(l\\)


#### Properties

- **<span style="color:Red">Collision Resistant (CR)</span>**

    $$
    Pr[\text{HashColl}_{\mathcal{A},{H^s}}(\lambda) = 1] \leq negl(\lambda)
    $$  

    where \\(H^s: \{0,1\}^{l'(\lambda)} \rightarrow \{0,1\}^{l(\lambda)}\\) with \\(s \leftarrow Gen(\lambda)\\) and \\(l'(\lambda) > l(\lambda)\\)

    Note: \\(s\\) is public and need not be random.

    The \\(\text{HashColl}_{\mathcal{A},{H^s}}(\lambda)\\) Process:

    1. \\(s \xleftarrow{\$} Gen(1^\lambda)\\)
   
    2. \\((x,y) \leftarrow \mathcal{A}(1^\lambda,s)\\)

    3. return \\(1\\) when \\(x \neq y \implies H^s(x) = H^s(y)\\) otherwise returns \\(0\\)

    ***An Easier Explanation:***

    It is hard to find different \\(m_0\\) and \\(m_1\\), such that \\(H(m_0) = H(m_1)\\)

- **<span style="color:Red">Preimage Resistance (PR1)</span>**

    For given \\(x \xleftarrow{\$} \{0,1\}^*, h := H^s(x)\\),

    it is infeasible for any PPT adversary \\(\mathcal{A}\\) who knows \\(s\\) and \\(h\\)

    to find \\(y \in \{0,1\}^*\\) which meets \\(h = H^s(y)\\)

    ***An Easier Explanation:***

    It is hard to find a \\(m\\) for a given \\(h\\), such that \\(h = H(m)\\)

- **<span style="color:Red">Second Preimage Resistance (PR2)</span>**

    For given \\(x \xleftarrow{\$} \{0,1\}^*, h := H^s(x)\\),

    it is infeasible for any PPT adversary \\(\mathcal{A}\\) who knows \\(s\\) and \\(x\\)

    to find \\(y \in \{0,1\}^*, y \neq x\\) which meets \\(h = H^s(y)\\)

    ***An Easier Explanation:***

    It is hard to find a different \\(m_1\\) for a given \\(m_0\\), such that \\(H(m_0) = H(m_1)\\)

**Relationship between Properties**

- if \\(H\\) is CR, then \\(H\\) is also PR2

- if \\(H\\) is PR2, then \\(H\\) is also PR1 (in practice)

#### Collisions

Since \\(l'(\lambda) > l(\lambda)\\), there must exist collisions

**Using Brute Force Attacks**

Takes exponential time complexity: \\(O(2^l)\\)

**Using Birthday Attacks**

Collision Probability

$$
\frac{q\cdot (q-1)}{4N} \leq Pr[C_{q,N}] \leq \frac{q \cdot (q-1)}{2N}
$$

where 

- \\(N\\) is the number of all possible outputs of \\(H\\) (i.e., \\(N = 2^l\\))

- \\(q\\) is the number of distinct inputs that are hashed

when \\(q \approx \sqrt N\\) with probability \\(\geq \frac{1}{2} − negl(\lambda)\\)

Takes reduced time complexity: \\(O(2^\frac{l}{2})\\) (still **NOT** against PR2 or PR1)


#### Application in Bitcoin: SHA2-256

**Merkle-Damgård Function**

**Davies-Meyer Compression Function**

#### Application in Ethereum: Keccak-256

[Keccak Specifications Summary](https://keccak.team/keccak_specs_summary.html)

**Sponge Function**

This is a special method for building cryptographic hash functions  
that can process an **<span style="color:Red">arbitrary-sized input</span>**  and produce an **<span style="color:Red">arbitrary-sized output</span>**.

<u>Parameters</u>

- State Size \\(b\\): total size of the internal state (e.g., 1600 bits for Keccak-256),

- Bitrate Size \\(r\\): the portion of the state that interacts with the input/output (e.g., 1088 bits for Keccak-256),

- Capacity Size \\(c = b - r\\): the portion of the state that provides security (e.g., 512 bits for Keccak-256).

Note: the security level is determined by half the capacity \\(\frac{c}{2}\\).

<u>Padding Scheme</u>

Use multi-rate padding:

1. First, appends a \\(1\\) bit

2. Then, followed by many \\(0\\) bits as needed

3. Finally, ends a \\(1\\) bit

to ensure the padded message length is a multiple of the rate \\(r\\).

<u>Absorbing Phase</u>

1. Set the initial state to zero

2. Split the padded message into \\(M_i\\) blocks (each block length is \\(r\\))

3. Update the first \\(r\\) bits of the current state by XORing with the block \\(M_i\\)

    $$
    state[\, 0: r-1\,] = state[\, 0: r-1\,] \,\oplus \, M_i
    $$

4. Get the next state by applying Keccak-\\(f[1600]\\) permutation function to the updated state

<u>Squeezing Phase</u>

The hash output is taken from the first \\(r\\)  bits of the state when all blocks are aborted

- If the desired hash length is less than or equal to \\(r\\) , it is extracted directly.

- If more output is needed (e.g., length \\(l\\)), take the first \\(r\\) bits of the state as \\(z_0\\),  
    and apply Keccak-\\(f[1600]\\) permutation function again, take the first \\(l-r\\) bits of the state,  
    if \\(l-r > r\\), continue the permutation to get \\(z_i\\), and finally concatenate them together to get the hash.

**Keccak-\\(f[1600]\\) Permutation Function**

<u>State Representation</u>

The state is a 3-dimensional array of bits arranged as \\(5 \times 5 \times w\\) (e.g., \\(w = 64\\) for Keccak-256).

<u>Round</u>

The number of rounds \\(n\\) depends on the permutation width \\(w = 2^l\\)  
and is given by \\(n = 12 + 2l\\) (e.g., \\(n = 24\\) for Keccak-256).

<u>Permutation Steps</u>

The state can be visualized as a \\(5 \times 5\\) grid of *lanes* and each *lane* is \\(w\\) bits long.

Each \\(5 \times 5\\) grid is called *slice* which has 5 *rows* and 5 *columns*

For each round, the permutation will perform the following steps

- \\(\theta\\) Step: computes the parity of each column and mixes this parity into the state (import in-slice diffusion)

- \\(\rho\\) Step: applies a cyclic shift (rotation) to each lane to spread bits over the lanes (import inter-slice diffusion)

- \\(\pi\\) Step: rearranges the positions of the lanes (complete diffusion)

- \\(\chi\\) Step: combines bits using a non-linear function (import non-linearity)

- \\(\iota\\) Step: adds a round constant to the state (break symmetry)

Note: please check the official specifications summary for more details.

---
### Merkle Trees

#### Definition

A Merkle tree is a tree data structure in which

- every leaf node contains the cryptographic hash of a data block, and

- every non-leaf node contains the cryptographic hash of its child nodes.

Given \\(n\\) inputs \\((x_0, x_1, \dots, x_{n-1})\\) with \\(x_j \in \{0,1\}^*\\), nodes \\(a_{i,j}\\) in the binary Merkle tree:

$$
a_{i,j} = \begin{cases}
\, H(x_j), & i = 0 \\
\, H(a_{i-1, 2j} \, || \, a_{i-1, 2j+1}), & 1 \leq i \leq k
\end{cases}
$$

where 

- \\(0 \leq j \leq \frac{n}{2^i} - 1\\)

- \\(k = log_2n\\) which is the Merkle tree height

- nodes \\(a_{i,j}\\) when \\(i = 0\\) are called *leaves*

- node \\(a_{i,j}\\) when \\(i = k\\) is called *Merkle root*

#### Operations

**Tree Creating**

The Merkle tree is created according to the definition

Note: if there is an odd number of leaf nodes, the last node is duplicated to form a pair.

**Root Calculating**

The Merkle root is calculated once the tree is created (\\(i = k\\))

Note: any change in any data block will alter the corresponding leaf hash and propagate changes along the path up to the root.

**Proof Generating**

1. Identify the target leaf hash: \\(H(x_j)\\).

2. Collect sibling hashes at each level: \\(k-1\\) hashes of sibling nodes are required to reconstruct the path to the root.

3. Generate proof: the proof \\(\pi\\) consists of the target leaf hash and the list of sibling hashes at each level.

**Inclusion Verifying**

The verification can be done by comparing the root from the reconstructed path according to the given proof.

**Tree Updating**

Updating (adding, removing, modifying) data blocks need to recompute the affected hashes.

**Tree Pruning**

Reduce storage requirements by 

- removing unnecessary parts of the tree, while 

- retaining the ability to verify data inclusion.

