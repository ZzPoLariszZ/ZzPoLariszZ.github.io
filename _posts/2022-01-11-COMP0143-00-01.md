---
layout: single
title: "Cryptography: Hash Functions"
excerpt_separator: <!--more-->
tags: UCL-Course COMP0143 Blockchain
author_profile: true
read_time: true
toc: true
classes: wide
---

UCL Course COMP0143 Cryptocurrencies: Prerequisite Cryptography Part I

<!--more-->

---
### Hash Functions

#### Motivation

Passwords stored in server database should not be stored in plaintext

Possible Solutions:

- Using encryption: have to care about the secret keys

- Using one-way function: have to care about the possible collisions

    e.g., given the one-way function \\(f\\), there could exist a password \\(pw^\prime \neq pw\\) but \\(f(pw^\prime) = f(pw)\\)


#### Definition

***Hash Function*** is a one-way function  

which maps **<span style="color:Red">arbitrary-sized</span>** input \\(m\\) into an output \\(h\\) with **<span style="color:Red">fixed-length</span>** \\(l\\)


#### Properties

- **<span style="color:Red">Collision Resistant (CR)</span>**

    $$
    Pr[\text{HashColl}_{\mathcal{A},{H^s}}(\lambda) = 1] \leq negl(\lambda)
    $$  

    where \\(H^s: \{0,1\}^{l'(\lambda)} \rightarrow \{0,1\}^{l(\lambda)}\\) with \\(s \leftarrow Gen(\lambda)\\) and \\(l'(\lambda) > l(\lambda)\\)

    Note: \\(s\\) is public and need not be random

    The \\(\text{HashColl}_{\mathcal{A},{H^s}}(\lambda)\\) Process:

    1. \\(s \xleftarrow{\$} Gen(1^\lambda)\\)
   
    2. \\((x,y) \leftarrow \mathcal{A}(1^\lambda,s)\\)

    3. return \\(1\\) when \\(x \neq y \implies H^s(x) = H^s(y)\\) otherwise returns \\(0\\)

    Such that it is hard to find different \\(m_0\\) and \\(m_1\\), such that \\(H(m_0) = H(m_1)\\)

- **<span style="color:Red">Preimage Resistance (PR1)</span>**

- **<span style="color:Red">Second Preimage Resistance (PR2)</span>**


---
### Merkle Trees