---
layout: single
title: "Cryptography: Public Key Encryption"
excerpt_separator: <!--more-->
tags: UCL-Course COMP0143 Blockchain Cryptography
author_profile: true
read_time: true
toc: true
classes: wide
---

UCL Course COMP0143 Cryptocurrencies: Prerequisite Cryptography Part II

<!--more-->

---
### Background

Public Key Encryption is initially designed to solve the **Key Distribution** problem in Private Key Encryption,  
where senders and receivers during the Private Key Encryption process have already shared a private key \\(k\\).

The key generation algorithm in Public Key Encryption splits the key into two parts:

- <u>Public Key</u> \\(pk\\): Anyone can encrypt information using the public key \\(pk\\).

- <u>Private Key</u>: \\(sk\\): Only who owns private key \\(sk\\) can decrypt the information.

**Relationships between Public Key and Private Key**

- Private key \\(sk\\) is chosen uniformly at random in some space.

- Public key \\(pk\\) is derived from private key \\(sk\\) via some function \\(f\\) such that \\(pk := f(sk)\\)

- Public key \\(pk\\) must be computationally infeasible to compute private key \\(sk\\)

    \\(\implies\\) the function \\(f\\) is a one-way function


---
### Definition

A Public Key Encryption (PKE) scheme defined over \\((\mathcal{K}, \mathcal{M}, \mathcal{C})\\) is a tuple of efficient algorithms \\((\text{Gen}, \text{Enc}, \text{Dec})\\):

- \\(\text{Gen}(\lambda)\\): Generate a public-private key pair \\((pk, sk)\\).

- \\(\text{Enc}(pk, m)\\): Encrypt the plaintext \\(m\\) using \\(pk\\) and output the ciphertext \\(c\\).

- \\(\text{Dec}(sk, c)\\): Decrypt the ciphertext \\(c\\) using \\(sk\\) and output the plaintext \\(m\\).

**Correctness**

$$
\forall \, \lambda \in \mathbb{N}, \forall \, (pk, sk) \xleftarrow{\$} \text{Gen}(\lambda), \forall \, m \in \mathcal{M}: \text{Dec}(sk, \text{Enc}(pk, m)) = m
$$

---
### IND-CPA

**IND-CPA** is short for **<span style="color:Red">Indistinguishable against Chosen-Plaintext Attacks</span>**.

$$
Pr[\text{Game}_{\mathcal{A}, \text{PKE}}^{\text{IND-CPA}}(\lambda) = 1] \leq \frac{1}{2} + negl(\lambda)
$$

where \\(\text{Game}_{\mathcal{A}, \text{PKE}}^{\text{IND-CPA}}(\lambda)\\):

1. Roles: Challenger and Adversary. Adversary has *implicit* access to Encryption Oracle since the PKE scheme is public.

2. \\((pk, sk) \xleftarrow{\$} \text{Gen}(\lambda)\\): Challenger generates \\((pk, sk)\\) and keeps \\(sk\\), then sends \\(pk\\) to Adversary.

3. \\((m_0, m_1) \leftarrow \mathcal{A}(\lambda, pk)\\): Adversary submits two distinct chosen plaintexts \\((m_0, m_1)\\)to Challenger.

4. \\(b \xleftarrow{\$} \{0,1\}\\): Challenger selects a bit uniformly at random.

5. \\(c \leftarrow Enc(pk, m_b)\\): Challenger sends the challenge ciphertext \\(c\\) back to Adversary.

6. \\(b^\prime \leftarrow \mathcal{A}(c)\\): Adversary outputs his guess for the value \\(b^\prime\\).

7. \\(\text{return} \ b == b^\prime\\): If the guessed value is the selected one, return \\(1\\); otherwise, return \\(0\\).

Note: IND-CPA is **<span style="color:Red">the weakest requirement</span>** for Public Key Encryption.

---
### IND-CCA

**<span style="color:Red">IND-CCA \\(\Rightarrow\\) IND-CPA but IND-CCA \\(\not\Leftarrow\\) IND-CPA</span>**

#### IND-CCA1

**IND-CCA1** is short for **<span style="color:Red">Indistinguishable against Non-Adaptive Chosen-Ciphertext Attacks</span>**.

$$
Pr[\text{Game}_{\mathcal{A}, \text{PKE}}^{\text{IND-CCA1}}(\lambda) = 1] \leq \frac{1}{2} + negl(\lambda)
$$

where \\(\text{Game}_{\mathcal{A}, \text{PKE}}^{\text{IND-CCA1}}(\lambda)\\):

1. Roles: Challenger and Adversary. <span style="color:Red">Adversary has access to both Encryption and Decryption Oracles</span>.

2. \\((pk, sk) \xleftarrow{\$} \text{Gen}(\lambda)\\): Challenger generates \\((pk, sk)\\) and keeps \\(sk\\), then sends \\(pk\\) to Adversary.

3. \\((m_0, m_1) \leftarrow \mathcal{A}^{\text{Dec}_{sk} \ (\cdot)} \ (\lambda, pk)\\): Adversary submits two distinct chosen plaintexts \\((m_0, m_1)\\)to Challenger.

4. \\(b \xleftarrow{\$} \{0,1\}\\): Challenger selects a bit uniformly at random.

5. \\(c \leftarrow Enc(pk, m_b)\\): Challenger sends the challenge ciphertext \\(c\\) back to Adversary.

6. \\(b^\prime \leftarrow \mathcal{A}(c)\\): Adversary outputs his guess for the value \\(b^\prime\\).

7. \\(\text{return} \ c \notin \mathcal{Q} \land b == b^\prime\\): If the guessed value is the selected one, return \\(1\\); otherwise, return \\(0\\).

Note: 

- \\(\text{Dec}_{sk} \ (\cdot)\\) is the Decryption Oracle,  
    \\(\mathcal{Q}\\) is all ciphertexts \\(c_j\\) queried by Adversary to ask for decryption,  
    Challenger decrypts \\(c_j\\) and sends \\(m_j = \text{Dec}(sk, c_j)\\) back to Adversary.

- <span style="color:Red">Adversary only has access to the Decryption Oracle \\(\text{Dec}_{sk} \ (\cdot)\\) before he receives \\(c\\)</span>.

#### IND-CCA2

**IND-CCA2** is short for **<span style="color:Red">Indistinguishable against Adaptive Chosen-Ciphertext Attacks</span>**

$$
Pr[\text{Game}_{\mathcal{A}, \text{PKE}}^{\text{IND-CCA2}}(\lambda) = 1] \leq \frac{1}{2} + negl(\lambda)
$$

where \\(\text{Game}_{\mathcal{A}, \text{PKE}}^{\text{IND-CCA2}}(\lambda)\\):

1. Roles: Challenger and Adversary. <span style="color:Red">Adversary has access to both Encryption and Decryption Oracles</span>.

2. \\((pk, sk) \xleftarrow{\$} \text{Gen}(\lambda)\\): Challenger generates \\((pk, sk)\\) and keeps \\(sk\\), then sends \\(pk\\) to Adversary.

3. \\((m_0, m_1) \leftarrow \mathcal{A}^{\text{Dec}_{sk} \ (\cdot)} \ (\lambda, pk)\\): Adversary submits two distinct chosen plaintexts \\((m_0, m_1)\\)to Challenger.

4. \\(b \xleftarrow{\$} \{0,1\}\\): Challenger selects a bit uniformly at random.

5. \\(c \leftarrow Enc(pk, m_b)\\): Challenger sends the challenge ciphertext \\(c\\) back to Adversary.

6. \\(b^\prime \leftarrow \mathcal{A}^{\text{Dec}_{sk} \ (\cdot)} \ (c)\\): Adversary outputs his guess for the value \\(b^\prime\\).

7. \\(\text{return} \ c \notin \mathcal{Q} \land b == b^\prime\\): If the guessed value is the selected one, return \\(1\\); otherwise, return \\(0\\).

Note: 

- \\(\text{Dec}_{sk} \ (\cdot)\\) is the Decryption Oracle,  
    \\(\mathcal{Q}\\) is all ciphertexts \\(c_j\\) queried by Adversary to ask for decryption,  
    Challenger decrypts \\(c_j\\) and sends \\(m_j = \text{Dec}(sk, c_j)\\) back to Adversary.

- <span style="color:Red">Adversary has access to the Decryption Oracle \\(\text{Dec}_{sk} \ (\cdot)\\) before and after he receives \\(c\\)</span>, such that   
    Adversary can adapt his decryption queries based on the challenge \\(c\\) he is trying to break (more powerful and realistic).

---
### RSA Cryptosystem

#### Integer Factorization Problem

Given an integer \\(n = pq\\) that is the product of two unknown primes \\(p\\) and \\(q\\),  
the Integer Factorization Problem (IFP) is defined as the problem of finding the factorization of \\(n\\) (finding \\(p\\) and \\(q\\)).

Note: A number \\(n \in \mathbb{N}\\) is called *prime* if it is only divisible by \\(1\\) and \\(n\\).

**Time Complexity**

<u>Brute Force</u>:  \\(O(2^{2\lambda} \cdot t)\\), where 

- \\(\lambda\\) is the length of \\(p\\) and \\(q\\), and 
  
- \\(t\\) is the time for division (testing the value \\(\frac{n}{x}\\) where \\(x\\) is the searched value).

<u>Slight Improvement</u>: \\(O(2^{\lambda} \cdot t)\\), since \\(p\\) and \\(q\\) have the same length \\(\lambda\\),   
the searched value should be limited \\(x \in [2, \dots, \sqrt n]\\); otherwise, the \\(pq > n\\).

**<span style="color:Red">There is currently NO known algorithm that can factor \\(n\\) in polynomial time (computationally hard).</span>**

**Extended Problem**

- It is hard to compute \\(\phi(n) = (p-1)(q-1)\\) if \\(p\\) and \\(q\\) are unknown, where \\(\phi(n)\\) is defined by *Euler's Totient Function*:

    $$
    \phi(n) = \prod_{i=1}^m p_i^{e_i-1}(p_i - 1)
    $$

    $$
    \phi(n) = \phi(pq) = \phi(p)\phi(q) = (p-1)(q-1)
    $$

- \\(\phi(n)\\) is the order of \\(\mathbb{Z}_n^{\*}\\) since it counts the number of integers less than \\(n\\)  that are co-prime to \\(n\\) (also elements in  \\(\mathbb{Z}_n^{\*}\\)). 

- Euler's Theorem: If \\(n \in \mathbb{N}\\),  \\(a \in [0, \dots, n - 1]\\), and \\(gcd(a, a) = 1\\), then

    $$
    a^{\phi(n)} \equiv 1 \, (\text{mod} \, n)
    $$

    This theorem can be used to get the inverse of \\(a\\):

    $$
    a^{-1} \equiv a^{\phi(n) - 1} \, (\text{mod} \, n)
    $$

#### Text-book RSA Encryption

**Key Generation**

- Pick two large random primes \\(p\\) and \\(q\\) of length \\(\lambda\\).

- Compute \\(n = pq\\) and \\(\phi(n) = (p-1)(q-1)\\).

- Pick a random integer \\(e \in [1, \dots, \phi(n)-1]\\) which is co-prime to \\(\phi(n)\\) \\(\implies gcd(e, \phi(n)) = 1\\).

- Compute the \\(d\\) which is the inverse of \\(e\\) such that \\(ed \equiv 1 \, (\text{mod} \, \phi(n))\\).

- The private key \\(sk = (d, n)\\) and public key \\(pk = (e, n)\\).

**Encryption**

$$
c \equiv m^e \, (\text{mod} \, n)
$$

**Decryption**

$$
m \equiv c^d \, (\text{mod} \, n)
$$

**Correctness**

According to Euler's Theorem,

$$
a^{\phi(n)} \equiv 1 \, (\text{mod} \, n)
$$

Therefore,

$$
m \equiv c^d \equiv {(m^e)}^d \equiv m^{ed} \equiv m^{1+k\phi(n)} \equiv m \Big({(m^{\phi(n)})}^k \Big) \equiv m(1^k) \equiv m \, (\text{mod} \, n)
$$

**Hardness**

$$
Pr[\text{Game}_{\mathcal{A}, \text{Gen}}^{\text{RSA}}(\lambda) = 1] \leq negl(\lambda)
$$

where \\(\text{Game}_{\mathcal{A}, \text{Gen}}^{\text{RSA}}(\lambda)\\):

1. Roles: Challenger and Adversary.

2. \\(\Big((e, n), (d, n) \Big) \xleftarrow{\$} \text{Gen}\\): Challenger generates \\(\Big((e, n), (d, n)\Big)\\) and keeps \\((d, n)\\), then sends \\((e, n)\\) to Adversary.

3. \\(c \xleftarrow{\$} \mathbb{Z}_n^{\*}\\): Challenger sends a random ciphertext \\(c\\) to Adversary.

4. \\(m \leftarrow \mathcal{A}(d, n, c)\\): Adversary outputs his plaintext and sends back to Challenger.

5.  \\(\text{return} \ m^e \equiv c \, (\text{mod} \, n)\\): If the output from Adversary meets the requirement, return \\(1\\); otherwise, return \\(0\\).

<span style="color:Red">RSA Problem \\(\leq\\) Integer Factorization Problem</span>

Let \\(\mathcal{A}\\) be a PPT adversary which breaks the hardness of RSA Cryptosystem.

Let \\(\mathcal{B}\\) be a PPT adversary  which breaks the hardness of Integer Factorization Problem.

According to the assumption of \\(\mathcal{B}\\)'s capability, \\(\mathcal{B}\\) can get \\(p\\) and \\(q\\), 

which means that \\(\mathcal{A}\\) can get \\((p-1)\\) and \\((q-1)\\) from \\(\mathcal{B}\\),  

which means that \\(\mathcal{A}\\) can output \\(\phi(n)\\),  

which means that \\(\mathcal{A}\\) can output \\(d\\) since \\(ed \equiv 1 \, (\text{mod} \, \phi(n))\\), 

which means that \\(\mathcal{A}\\) can output \\(m\\) that meets \\( m^e \equiv c \, (\text{mod} \, n)\\) to break RSA.

**Not Have IND-CPA Security**

<span style="color:Red">Text-book RSA does not have IND-CPA security since it is</span> *<span style="color:Red">deterministic</span>*  
where *Deterministic* means that the same input will always get the same output.

Since Adversary \\(\mathcal{A}\\) in \\(\text{Game}_{\mathcal{A}, \text{PKE}}^{\text{IND-CPA}}(\lambda)\\) gets \\(pk\\) and has access to Encryption Oracle,  
Adversary can always know \\(c_0\\) to \\(m_0\\) and \\(c_1\\) to \\(m_1\\), and then always output the correct \\(b' = b\\).

#### Message Encoding

Previously, the message for encryption should meet the requirement: \\(m \in \mathbb{Z}_n^{\*}\\).

However, messages are typically given as binary strings having arbitrary length \\(M \in \\{0, 1\\}^{\*}\\).

Let \\(l := \|n\|\\) be the length of \\(n\\) in bits, and binary string \\(M\\) should meet \\(\|M\| < \|n\| = l\\)

Therefore, binary string \\(M\\) with length \\(l-1\\) must be an element of \\(\mathbb{Z}_n\\) (\\(M < n\\)).

- If \\(M \in \mathbb{Z}_n^{\*}\\), the proof of correctness can be done directly as above.

- If \\(M \in \mathbb{Z}_n \setminus \mathbb{Z}_n^{\*}\\), which means \\(gcd(m, n) \neq 1\\)

    since \\(n = pq\\) and \\(M < n\\), there will exist 3 cases to consider:

    - \\(M = 0\\)

        $$
        M \equiv 0 \equiv c^d \equiv {(0^e)}^d \equiv 0^{ed} \equiv 0 \equiv M \, (\text{mod} \, n)
        $$

    - \\(gcd(M, n) = p\\)

        (1) According to GCD's Definition,

        $$
        M = kp \implies gcd(M, p) = p \implies M \equiv 0  \, (\text{mod} \, p)
        $$

        (2) Since \\(p\\) and \\(q\\) are two large random primes,
        
        $$
        gcd(M, q) = 1 \implies M \in \mathbb{Z}_q^*
        $$

        According to Euler's Theorem,

        $$
        M^{q-1} \equiv 1 \, (\text{mod} \, q)
        $$

        (3) According to Chinese Remainder Theorem,

        $$
        M \, (\text{mod} \, n) \mapsto \Big(M \, (\text{mod} \, p), \ M \, (\text{mod} \, q) \Big)
        $$

        (4) Consider \\(\text{mod} \, p\\) and \\(\text{mod} \, q\\) separately

        $$
        M \equiv 0 \equiv c^d \equiv {(0^e)}^d \equiv 0^{ed} \equiv 0 \equiv M \, (\text{mod} \, p)
        $$

        $$
        M \equiv c^d \equiv {(M^e)}^d \equiv M^{ed} \equiv M^{1+k(p-1)(q-1)} \equiv M^{1+k^\prime(q-1)} \equiv M \Big({(M^{q-1})}^{k^\prime} \Big) \equiv M(1^{k^\prime}) \equiv M \, (\text{mod} \, q)
        $$

        Therefore, 

        $$
        M \equiv c^d \equiv M \, (\text{mod} \, n)
        $$

    - \\(gcd(M, n) = q\\) is similar.

#### Padded RSA Encryption

To solve the *deterministic* problem in Text-book RSA Encryption,

Let \\(\forall \ \lambda: l(\lambda) \leq 2\lambda - 2\\), and \\(\mathcal{M} = \\{0,1\\}^{l(\lambda)}\\)

- \\(\text{Gen}(\lambda)\\): return \\(sk = (d, n)\\) and \\(pk = (e, n)\\) where \\(\|n\| = 2\lambda\\)
    
- \\(Enc_{\{e,n\}}(m): c \leftarrow (r \, \parallel \, m)^e \ mod \ n\\) where \\(r \xleftarrow{\$} \\{0,1\\}^{\|n\| - l(\lambda) - 1}\\)
    
- \\(Dec_{\{d,n\}}(c): m \leftarrow \lfloor c^d \ mod \ n \rfloor _{l(\lambda)}\\)

    which means returning the \\(l(\lambda)\\) lower bits of \\(m^\prime = c^d \ mod \ n\\)

**Have IND-CPA Security**

\\(l(\lambda)\\) cannot be too large since the length of \\(r\\) will relatively too small   
such that a brute force attack over \\(r\\) may be possible.

For example, \\(l(\lambda) \geq 2\lambda - O(log\lambda)\\), the required trials for a CPA attack is \\(2^{O(log\lambda)}\\),  
therefore, for \\(l(\lambda) = O(log\lambda)\\), padded RSA encryption is IND-CPA secure.

**Have IND-CCA2 Security ???**

- [RSA Encryption with PKCS #1 v1.5](https://en.wikipedia.org/wiki/PKCS_1) is susceptible to Bleichenbacher's Padding Oracle Attack (Not have IND-CCA2 Security).

- [RSA Encryption with OAEP](https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding) has IND-CCA2 security if the based Hash Functions are Random Oracles.

---
### ElGamal Cryptosystem

#### Discrete Logarithm Problem

Given a cyclic group \\(\mathbb{G} = \langle g \rangle \\) of order \\(q\\) with generator \\(g\\), and some element \\(h \in \mathbb{G}\\),  
the Discrete Logarithm Problem (DLP) is defined as the problem of finding \\(x \in \mathbb{Z}_q\\) such that \\(h = g^x\\).

Note:

- A group \\(\mathbb{G}\\) is called *cyclic* if it is generated by a single element \\(g \in \mathbb{G}\\).

- The order \\(q\\) is the number of elements in \\(\mathbb{G}\\): \\(q = \|\mathbb{G}\|\\).

- The element \\(g\\) is the generator of \\(\mathbb{G}\\) such that \\(\mathbb{G} = \\{\, g^0, g^1, \dots, g^{q-1} \,\\}\\)

- Any element \\(h \in \mathbb{G}\\) can be represented as \\(h = g^x\\) for some \\(x \in \mathbb{Z}_q\\).

**<span style="color:Red">There is currently NO known algorithm that can get \\(x\\) in polynomial time (computationally hard) if the order \\(q\\)is a large prime.</span>**

---
### Cramer–Shoup Cryptosystem

#### Computationally Hard Problem

---
### Hybrid Encryption