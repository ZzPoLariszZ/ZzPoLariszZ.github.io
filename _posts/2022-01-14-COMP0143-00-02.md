---
layout: single
title: "Cryptography: Public Key Encryption"
excerpt_separator: <!--more-->
tags: UCL-Course COMP0143 Blockchain Cryptography
author_profile: true
read_time: true
toc: true
classes: wide
---

UCL Course COMP0143 Cryptocurrencies: Prerequisite Cryptography Part II

<!--more-->

---
### Background

Public Key Encryption is initially designed to solve the **Key Distribution** problem in Private Key Encryption,  
where senders and receivers during the Private Key Encryption process have already shared a private key \\(k\\).

The key generation algorithm in Public Key Encryption splits the key into two parts:

- <u>Public Key</u> \\(pk\\): Anyone can encrypt information using the public key \\(pk\\).

- <u>Private Key</u>: \\(sk\\): Only who owns private key \\(sk\\) can decrypt the information.

**Relationships between Public Key and Private Key**

- Private key \\(sk\\) is chosen uniformly at random in some space.

- Public key \\(pk\\) is derived from private key \\(sk\\) via some function \\(f\\) such that \\(pk := f(sk)\\)

- Public key \\(pk\\) must be computationally infeasible to compute private key \\(sk\\)

    \\(\implies\\) the function \\(f\\) is a one-way function


---
### Definition

A Public Key Encryption (PKE) scheme defined over \\((\mathcal{K}, \mathcal{M}, \mathcal{C})\\) is a tuple of efficient algorithms \\((\text{Gen}, \text{Enc}, \text{Dec})\\):

- \\(\text{Gen}(\lambda)\\): Generate a public-private key pair \\((pk, sk)\\).

- \\(\text{Enc}(pk, m)\\): Encrypt the plaintext \\(m\\) using \\(pk\\) and output the ciphertext \\(c\\).

- \\(\text{Dec}(sk, c)\\): Decrypt the ciphertext \\(c\\) using \\(sk\\) and output the plaintext \\(m\\).

**Correctness**

$$
\forall \, \lambda \in \mathbb{N}, \forall \, (pk, sk) \xleftarrow{\$} \text{Gen}(\lambda), \forall \, m \in \mathcal{M}: \text{Dec}(sk, \text{Enc}(pk, m)) = m
$$

---
### IND-CPA

**IND-CPA** is short for **<span style="color:Red">Indistinguishable against Chosen-Plaintext Attacks</span>**.

$$
Pr[\text{Game}_{\mathcal{A}, \text{PKE}}^{\text{IND-CPA}}(\lambda) = 1] \leq \frac{1}{2} + negl(\lambda)
$$

where \\(\text{Game}_{\mathcal{A}, \text{PKE}}^{\text{IND-CPA}}(\lambda)\\):

1. Roles: Challenger and Adversary. Adversary has *implicit* access to Encryption Oracle since the PKE scheme is public.

2. \\((pk, sk) \xleftarrow{\$} Gen(\lambda)\\): Challenger generates \\((pk, sk)\\) and keeps \\(sk\\), then sends \\(pk\\) to Adversary.

3. \\((m_0, m_1) \leftarrow \mathcal{A}(\lambda, pk)\\): Adversary submits two distinct chosen plaintexts \\((m_0, m_1)\\)to Challenger.

4. \\(b \xleftarrow{\$} \{0,1\}\\): Challenger selects a bit uniformly at random.

5. \\(c \leftarrow Enc(pk, m_b)\\): Challenger sends the challenge ciphertext \\(c\\) back to Adversary.

6. \\(b^\prime \leftarrow \mathcal{A}(c)\\): Adversary outputs his guess for the value \\(b^\prime\\).

7. \\(\text{return} \ b == b^\prime\\): If the guessed value is the selected one, return \\(1\\); otherwise, return \\(0\\).

Note: IND-CPA is **<span style="color:Red">the weakest requirement</span>** for Public Key Encryption.

---
### IND-CCA

#### IND-CCA1

**IND-CCA1** is short for **<span style="color:Red">Indistinguishable against Non-Adaptive Chosen-Ciphertext Attacks</span>**.

$$
Pr[\text{Game}_{\mathcal{A}, \text{PKE}}^{\text{IND-CCA1}}(\lambda) = 1] \leq \frac{1}{2} + negl(\lambda)
$$

where \\(\text{Game}_{\mathcal{A}, \text{PKE}}^{\text{IND-CCA1}}(\lambda)\\):

1. Roles: Challenger and Adversary. <span style="color:Red">Adversary has access to both Encryption and Decryption Oracles</span>.

2. \\((pk, sk) \xleftarrow{\$} Gen(\lambda)\\): Challenger generates \\((pk, sk)\\) and keeps \\(sk\\), then sends \\(pk\\) to Adversary.

3. \\((m_0, m_1) \leftarrow \mathcal{A}^{\text{Dec}_{sk} \ (\cdot)} \ (\lambda, pk)\\): Adversary submits two distinct chosen plaintexts \\((m_0, m_1)\\)to Challenger.

4. \\(b \xleftarrow{\$} \{0,1\}\\): Challenger selects a bit uniformly at random.

5. \\(c \leftarrow Enc(pk, m_b)\\): Challenger sends the challenge ciphertext \\(c\\) back to Adversary.

6. \\(b^\prime \leftarrow \mathcal{A}(c)\\): Adversary outputs his guess for the value \\(b^\prime\\).

7. \\(\text{return} \ c \notin \mathcal{Q} \land b == b^\prime\\): If the guessed value is the selected one, return \\(1\\); otherwise, return \\(0\\).

Note: 

- \\(\text{Dec}_{sk} \ (\cdot)\\) is the Decryption Oracle,  
    \\(\mathcal{Q}\\) is all ciphertexts \\(c_j\\) queried by Adversary to ask for decryption,  
    Challenger decrypts \\(c_j\\) and sends \\(m_j = \text{Dec}(sk, c_j)\\) back to Adversary.

- <span style="color:Red">Adversary only has access to the Decryption Oracle \\(\text{Dec}_{sk} \ (\cdot)\\) before he receives \\(c\\)</span>.

#### IND-CCA2

**IND-CCA2** is short for **<span style="color:Red">Indistinguishable against Adaptive Chosen-Ciphertext Attacks</span>**

$$
Pr[\text{Game}_{\mathcal{A}, \text{PKE}}^{\text{IND-CCA2}}(\lambda) = 1] \leq \frac{1}{2} + negl(\lambda)
$$

where \\(\text{Game}_{\mathcal{A}, \text{PKE}}^{\text{IND-CCA2}}(\lambda)\\):

1. Roles: Challenger and Adversary. <span style="color:Red">Adversary has access to both Encryption and Decryption Oracles</span>.

2. \\((pk, sk) \xleftarrow{\$} Gen(\lambda)\\): Challenger generates \\((pk, sk)\\) and keeps \\(sk\\), then sends \\(pk\\) to Adversary.

3. \\((m_0, m_1) \leftarrow \mathcal{A}^{\text{Dec}_{sk} \ (\cdot)} \ (\lambda, pk)\\): Adversary submits two distinct chosen plaintexts \\((m_0, m_1)\\)to Challenger.

4. \\(b \xleftarrow{\$} \{0,1\}\\): Challenger selects a bit uniformly at random.

5. \\(c \leftarrow Enc(pk, m_b)\\): Challenger sends the challenge ciphertext \\(c\\) back to Adversary.

6. \\(b^\prime \leftarrow \mathcal{A}^{\text{Dec}_{sk} \ (\cdot)} \ (c)\\): Adversary outputs his guess for the value \\(b^\prime\\).

7. \\(\text{return} \ c \notin \mathcal{Q} \land b == b^\prime\\): If the guessed value is the selected one, return \\(1\\); otherwise, return \\(0\\).

Note: 

- \\(\text{Dec}_{sk} \ (\cdot)\\) is the Decryption Oracle,  
    \\(\mathcal{Q}\\) is all ciphertexts \\(c_j\\) queried by Adversary to ask for decryption,  
    Challenger decrypts \\(c_j\\) and sends \\(m_j = \text{Dec}(sk, c_j)\\) back to Adversary.

- <span style="color:Red">Adversary has access to the Decryption Oracle \\(\text{Dec}_{sk} \ (\cdot)\\) before and after he receives \\(c\\)</span>,  
    such that Adversary can adapt his decryption queries based on the challenge \\(c\\) he is trying to break (more powerful and realistic).

---
### RSA Cryptosystem

---
### ElGamal Cryptosystem

---
### Cramerâ€“Shoup Cryptosystem

---
### Hybrid Encryption