---
layout: single
title: "Cryptography: Commitment Schemes"
excerpt_separator: <!--more-->
tags: UCL-Course COMP0143 Blockchain Cryptography
author_profile: true
read_time: true
toc: true
classes: wide
---

UCL Course COMP0143 Cryptocurrencies: Prerequisite Cryptography Part IV

<!--more-->

---
### Scenario: Sealed-Bid Auctions

**Process**

- *Bidding Stage*: Bidders submit their sealed bids.

- *Opening Stage*: All bids are opened and the highest one wins.

**Protection against Cheating**

- *Bidding Stage*: A sealed bid \\(c_i\\) should not leak any information about the bid \\(b_i\\).

- *Opening Stage*: A bidder should not be able to open its bid to another one \\(b^\prime_i \neq b_i\\).

---
### Definition 

Commitment Scheme is an interactive protocol between a sender \\(S\\) and a receiver \\(R\\).

#### Components

- **Commit**

	Sender \\(S\\) sends a commitment \\(c := \text{Commit}(m,r)\\) to receiver \\(R\\)  
	where \\(m\\) is the message and \\(r\\) is a randomness.

- **Reveal**

	Sender \\(S\\) reveals \\(c\\) by sending \\(m\\) and \\(r\\) to receiver \\(R\\)  
	who accepts if \\(c =  \text{Commit}(m,r)\\).


#### Security Goal

- **Hiding**

	Receiver \\(R\\) should not be able to obtain any information about \\(m\\) from \\(c\\).

- **Binding**

	Sender \\(S\\) should not be able to reveal \\(c\\) to any other message \\(m^\prime \neq m\\).


#### Adversary Types

- **Hiding-Adversary \\(\mathcal{A}\\)** (role as Receiver \\(R\\))

    who aims to learn information about \\(m\\) from \\(c := \text{Commit}(m,r)\\).

- **Binding-Adversary \\(\mathcal{A}\\)** (role as Sender \\(S\\))

    who aims to find \\((m, r)\\) and \\((m^\prime, r^\prime)\\) that meets \\(\text{Commit}(m,r) = \text{Commit}(m^\prime,r^\prime)\\) and \\(m \neq m^\prime\\).


---
### Pedersen Commitment

#### Protocol

Let \\(<\mathbb{G}, q, g>\\) be a cyclic group where \\(\|\mathbb{G}\| = q\\)  
and \\(g\\) is the generator in which the Discrete Logarithm Problem is hard.

Let \\(h\\) be a randomly chosen generator of \\(\mathbb{G}\\) with \\(g \neq h\\)   
and assume the discrete logarithm \\(x\\) such that \\(h = g^x\\) is unknown.

- **Commit**

	Sender \\(S\\) chooses \\(m \in \mathbb{Z}_q\\) and picks \\(r \xleftarrow{\$} \mathbb{Z}_q\\).
	
	Sender \\(S\\) sends commitment \\(c := g^mh^r\\) to receiver \\(R\\).

- *Reveal*

	Sender \\(S\\) reveals \\(c\\) by sending \\(m\\) and \\(r\\) to receiver \\(R\\) who accepts if \\(c = g^mh^r\\).

#### Hiding Security of Pedersen Commitment

The *Hiding* of Pedersen Commitment provides ***<span style="color:Red">Perfect Security</span>***.

**Proof**

Assume adversary \\(\mathcal{A}\\) is even information-theoretic (knows \\(x = log_gh \implies h = g^x\\)).

Then, the commitment \\(c := g^mh^r = g^m (g^x)^r = g^{m + xr}\\).

The value \\(a = m + xr\\) is uniformly distributed in \\(\mathcal{Z}_q\\) since \\(r \xleftarrow{\$} \mathcal{Z}_q\\).

Then, for any given message \\(m^\prime \in \mathcal{Z}_q\\), there exists an unique \\(r^\prime \in \mathcal{Z}_q\\) meets \\(a = m^\prime + xr^\prime\\).

Then, for any message \\(m^\prime\\) with \\(m^\prime = m\\) or \\(m^\prime \neq m\\), there exists \\(r^\prime\\) meets \\(c = g^{m^\prime}h^{r^\prime}\\).

Therefore, adversary \\(\mathcal{A}\\) cannot distinguish which message is hidden in \\(c\\).

#### Binding Security of of Pedersen Commitment

The *Binding* of Pedersen Commitment provides ***<span style="color:Red">Computational Security</span>***

**Proof**

Assume Pedersen commitment scheme does not provide computationally secure binding when the Discrete Logarithm Problem is hard.

Let \\(\mathcal{A}\\) be a PPT adversary which breaks the binding property.

Let \\(\mathcal{B}\\)  be a PPT adversary against Discrete Logarithm Problem that simulates Pedersen Commitment for \\(\mathcal{A}\\).

By reduction:

- \\(\mathcal{A}\\) requests a new commitment from \\(\mathcal{B}\\) such that

    \\(\mathcal{B}\\) chooses \\(m \in \mathcal{Z}_q\\), picks \\(r \xleftarrow{\$} \mathcal{Z}_q\\), and returns \\(c = g^mh^r\\) to \\(\mathcal{A}\\).

- \\(\mathcal{A}\\) requests to de-commit \\(c\\) from \\(\mathcal{B}\\) such that

    \\(\mathcal{B}\\) sends \\(m, r\\) to \\(\mathcal{B}\\).

- According to the assumption of \\(\mathcal{A}\\)'s capability,  

    \\(\mathcal{A}\\) can return \\(m, r\\) and \\(m^\prime, r^\prime\\) to \\(\mathcal{B}\\) and break binding successfully,

    which means that \\(c = g^mh^r = g^{m^\prime}h^{r^\prime} = c^\prime\\)

