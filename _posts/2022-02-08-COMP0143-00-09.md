---
layout: single
title: "Cryptography: Anonymity Systems"
excerpt_separator: <!--more-->
tags: UCL-Course COMP0143 Blockchain Cryptography
author_profile: true
read_time: true
toc: true
classes: wide
---

UCL Course COMP0143 Cryptocurrencies: Prerequisite Cryptography Part IX

<!--more-->

---
### Type of Anonymity

**Sender Anonymity**

Alice sends a message to Bob. Bob cannot know who Alice is.

**Receiver Anonymity**

Alice can send a message to Bob, but cannot find out who Bob is.

**Bi-directional Anonymity**

Alice and Bob can talk to each other, but neither of them know the identity of the other.

**Third Party Anonymity**

Alice and Bob converse and know each other, but third party cannot find this out.

---
### Properties of Anonymity

**Unobservability**

Alice and Bob communicate, but no one can tell if they are transmitting or receiving messages.

**Unlinkability**

Message-Level: Two messages sent (received) by Alice (Bob) cannot be linked to the same sender (receiver).

Relationship-Level: One message sent by Alice and received by Bob, where Alice and Bob cannot be linked.

**Pseudonymity**

All actions can be linkable to a pseudonym but be unlinkable to a principal.

---
### High-latency Anonymity Systems

#### Anonymity Provided by Broadcast

**Process**

One sender can broadcast encrypted messages to many receivers (1-to-N)  
such that only the receivers who can decrypt will get the message  
but others cannot know which receivers can decrypt.

**Pros**

- *Simple* (can be done by trees, rings, buses, etc.)

- *Receiver Anonymity*

**Cons**

- *Coordination ?*

	It is hard for the sender to know all the possible receivers.

- *Sender Anonymity ?*

	All receivers can know the sender.

- *Efficiency ?*

	Problems in latency (when all receivers receive) and bandwidth (need broadcast)  
    especially in a large system (utility will be quite low).

#### Anonymity Provided by Mix

**Process**

1. Multiple senders send messages to a Mix. For example,

	$$
    \text{Alice} \rightarrow \text{Mix}: \{\ \text{Bob}, \, \text{Msg} \ \}_{pk_{\text{Mix}}}
    $$

	where the destination and message are encrypted by public key \\(pk\\) of the Mix.

2. The Mix decrypt to get the destination and message by its private key \\(sk\\)

3. The Mix send the message to the destination. For example,

	$$
    \text{Mix} \rightarrow \text{Bob}: \text{Msg}
    $$

**Mix Requirements**

- <u>Public Key Encryption</u>

- <u>Enough Honest Mix Participants</u>

    Can be more secure if there are more honest Mix participants in one round.

- <u>Bitwise Unlinkability</u>

    Cannot link the corresponding input and output messages of the Mix by bit pattern.

- <u>Traffic Analysis Resistance</u>

    Cannot link the corresponding inputs and outputs of the Mix by metadata (e.g., address, time, size, etc.).

**Pros**

- *Sender Anonymity*

- *Relationship-Level Unlinkability* 

    Cannot link the corresponding input and output messages (sender and receiver)

**Cons**

- *High costs* for all requirements

- *Mix itself can be untrusted*

- *Other Mix participants can be untrusted*

---
### Attacks to Mix

#### Active Attacks against Bitwise Unlinkability

**Tagging Attack**

If it is a Mix using *Steam Cipher*,

$$
\{ \ \text{Msg} \ \}_{pk_{\text{Mix}}} := \{\ k \ \}_{pk_{\text{Mix}}}, \ \text{Msg} \, \oplus \, \textit{Stream}_k
$$

where \\(k\\) is a fresh key for this message \\(\text{Msg}\\).

Then,

- Adversary can eavesdrop and manipulate the encrypted input (i.e., flipping the last bit)

    $$
    \{\ \text{Bob}, \, \text{Msg} \ \}_{pk_{\text{Mix}}} \rightarrow \{\ \text{Bob}, \, \text{Msg} \ \}_{pk_{\text{Mix}}} \, \oplus (\ \dots 0001 \ )
    $$

- Adversary may find the output like

    $$
    \text{Mix} \rightarrow \text{Bob}: \text{Msg} \, \oplus \, (\ \dots 0001 \ )
    $$

**Possible Solution**

[Mixminion](https://www.mixminion.net/) (the example designed by [George Danezis](https://scholar.google.com/citations?hl=en&user=LCNVGpcAAAAJ) et al.)

- *Detect modification*

    Use cryptographic checksums to protect the message header.

- *Destroy necessary information*
  
  Destroy the addressing information contained in the message header  if the message payload is modified by an adversary.


#### Passive Attacks against Traffic Analysis Resistance

**Order Attack**

If it is a Mix using First-In-First-Out (FIFO) mechanism,

then adversary can simple counts the number since this Mix sends messages out in the order they came in.

**Possible Solution**

- *Threshold*

    Wait for \\(N\\) messages and output them in a random order.

- *Pool*

    1. There is a pool of \\(n\\) messages

    2. Wait for \\(N\\) messages

    3. Output \\(N\\) out of a total of \\(N + n\\) messages

    4. Keep \\(n\\) messages remaining in the pool (back to Step 1)

#### Untrusted Mix

One key problem of anonymity provided by Mix is **<span style="color:Red">the need to trust the Mix itself</span>**.

**Possible Solution**

<u>Mix Cascades</u>

All messages are routed through a preset mix sequence (fixed path).  

*Security Parameter*: the length of sequence \\(O(\|Mixes\|)\\).

<u>Free Routing</u>

All messages are routed through a random sequence of mixes (nested encrypted).  

For example,

$$
\text{Alice} \rightarrow \text{Mix}_2: \{ \ \text{Mix}_4: \{ \ \text{Mix}_1: \{\text{Bob}, \ \text{Msg} \ \}_{pk_{\text{Mix}_1}} \ \}_{pk_{\text{Mix}_4}} \ \}_{pk_{\text{Mix}_2}}
$$

The path is `Alice -> Mix_2 -> Mix_4 -> Mix_1 -> Bob`.

*Security Parameter*: the length of sequence \\(O(log(\|Mixes\|))\\).

**Requirements**

- <u>Bitwise Unlinkability</u>: Length invariance and Replay prevention.

- <u>Mix Discovery</u>: Mixers need to be authoritative, comprehensive, and common.

- <u>Hidden Information</u>: The step number and total path length should be hidden.

#### Untrusted Mix Participants

Another key problem of anonymity provided by Mix is **<span style="color:Red">the need to trust the Mix participants</span>**.

**N - 1 Attacks**

<u>Process</u>

1. Wait or flush the Mix.

2. Block all incoming messages (trickle) and inject messages from the attacker (flood).

3. Allow only \\(1\\) message from the benign user but \\(N-1\\) messages from the attacker.

4. Identify the output that not belongs to the attacker will belong to the benign user.

**Possible Solution**

- *Strong Identification*: ensure distinct identities (might not be accepted by users).

- *Message Expiration*: discard messages after a deadline to prevent the mix flushing.

- *Heartbeat Traffic*: route messages to their senders to detect whether messages are blocked or not.

---
### Low-Latency Anonymity Systems

#### Anonymity Provided by Tor

---
### Attacks to Tor

---
### Difference between Mix and Tor

---
### Requirements for Cryptography